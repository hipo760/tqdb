#!/usr/bin/python3
# -*- coding: utf-8 -*-

"""
TQ Database Import Status Monitor CGI Script

This CGI script provides real-time monitoring of data import operations in the TQ Database system.
It displays the progress and status of minute-level data import jobs by reading log files and
presenting them in a live-updating HTML interface.

Key Features:
- Real-time import progress monitoring via log file tailing
- Auto-refreshing HTML interface with live updates
- Import completion detection and notification
- JavaScript-based auto-scrolling to show latest log entries
- Ticket-based import job tracking

Import Process Integration:
- Works with i1min_do.py import initiation script
- Monitors log files generated during import operations
- Provides user feedback for long-running import processes
- Detects completion markers in import logs

Web Interface Features:
- HTML output with styled log display
- Auto-refresh every 1 second until completion
- Auto-scroll to bottom to show latest entries
- Responsive design for monitoring dashboards

Author: TQ Database Team
Compatible with: Python 3.x, Rocky Linux 9.0+, Web Browsers
"""

import sys
import os
from urllib.parse import unquote


# Global configuration constants
CASSANDRA_IP = "127.0.0.1"  # Cassandra cluster IP address
CASSANDRA_DB = "tqdb1"  # TQ Database keyspace name
LOG_FILE_DIRECTORY = "/tmp"  # Directory for import log files
COMPLETION_MARKER = "Importing finish!"  # Text marker indicating import completion
REFRESH_INTERVAL = 1000  # Auto-refresh interval in milliseconds (1 second)


def parse_query_parameters():
    """
    Parse CGI query string parameters for import status monitoring.
    
    Returns:
        dict: Parsed parameters containing:
            - importTicket: Unique identifier for the import job to monitor
            
    Query String Format:
        ?importTicket=unique_import_id_timestamp
        
    Import Ticket:
        - Generated by i1min_do.py when starting import operations
        - Used to identify specific import job and its log file
        - Typically timestamp-based for uniqueness
        
    Note:
        URL decoding is applied to handle special characters in ticket IDs
    """
    query_string = os.environ.get("QUERY_STRING", "NA=NA")
    params = {}
    
    # Parse each parameter from query string
    for qs in query_string.split("&"):
        if "=" not in qs:
            continue
        key, value = qs.split("=", 1)
        params[key] = unquote(value)
    
    return params


def generate_html_header():
    """
    Generate HTML document header with content type and basic structure.
    
    Returns:
        str: HTML header content including content-type declaration
        
    HTML Structure:
        - Sets content-type to text/html for browser rendering
        - Opens basic HTML document structure
        - Prepared for log content injection
    """
    header = []
    header.append("Content-Type: text/html; charset=UTF-8\r\n")
    header.append("\r\n")
    header.append("<html>\n")
    header.append("<head>\n")
    header.append("    <title>TQ Database Import Status</title>\n")
    header.append("    <style>\n")
    header.append("        body { font-family: monospace; margin: 20px; }\n")
    header.append("        .log-container { background: #f5f5f5; padding: 10px; border: 1px solid #ddd; }\n")
    header.append("        .log-line { margin: 2px 0; }\n")
    header.append("        .status { font-weight: bold; color: #0066cc; }\n")
    header.append("        .error { color: #cc0000; }\n")
    header.append("        .success { color: #006600; }\n")
    header.append("    </style>\n")
    header.append("</head>\n")
    header.append("<body>\n")
    header.append("    <h2>TQ Database Import Status Monitor</h2>\n")
    header.append("    <div class='log-container'>\n")
    
    return "".join(header)


def read_import_log(log_file_path):
    """
    Read and process import log file content.
    
    Args:
        log_file_path (str): Full path to the import log file
        
    Returns:
        tuple: (log_lines, is_finished)
            - log_lines (list): List of log line strings
            - is_finished (bool): True if import completion marker found
            
    Log Processing:
        1. Reads entire log file content
        2. Processes each line for display formatting
        3. Detects completion markers in log content
        4. Handles file access errors gracefully
        
    Completion Detection:
        - Searches for COMPLETION_MARKER text in log lines
        - Used to stop auto-refresh when import finishes
        - Provides user feedback on import status
        
    Error Handling:
        - Returns empty list if log file doesn't exist
        - Handles file permission and I/O errors
        - Graceful degradation for monitoring experience
    """
    log_lines = []
    is_finished = False
    
    try:
        with open(log_file_path, 'r', encoding='utf-8', errors='replace') as f:
            for line in f:
                # Strip newline and add to lines list
                clean_line = line.rstrip('\n\r')
                log_lines.append(clean_line)
                
                # Check for completion marker
                if COMPLETION_MARKER in line:
                    is_finished = True
                    
    except FileNotFoundError:
        log_lines.append("Log file not found. Import may not have started yet.")
    except PermissionError:
        log_lines.append("Permission denied accessing log file.")
    except Exception as e:
        log_lines.append(f"Error reading log file: {str(e)}")
    
    return log_lines, is_finished


def format_log_line(line):
    """
    Format a single log line for HTML display with appropriate styling.
    
    Args:
        line (str): Raw log line content
        
    Returns:
        str: HTML-formatted log line with CSS classes
        
    Formatting Rules:
        - Error messages: Apply 'error' CSS class
        - Success messages: Apply 'success' CSS class  
        - Status updates: Apply 'status' CSS class
        - Default: Basic log-line formatting
        
    HTML Escaping:
        - Escapes HTML special characters in log content
        - Prevents XSS and display issues
        - Maintains log content integrity
    """
    # HTML escape the line content
    import html
    escaped_line = html.escape(line)
    
    # Apply CSS classes based on content
    if any(keyword in line.lower() for keyword in ['error', 'failed', 'exception']):
        return f"<div class='log-line error'>{escaped_line}</div>"
    elif any(keyword in line.lower() for keyword in ['success', 'complete', 'finish']):
        return f"<div class='log-line success'>{escaped_line}</div>"
    elif any(keyword in line.lower() for keyword in ['status', 'progress', 'processing']):
        return f"<div class='log-line status'>{escaped_line}</div>"
    else:
        return f"<div class='log-line'>{escaped_line}</div>"


def generate_javascript_controls(is_finished):
    """
    Generate JavaScript code for auto-refresh and scroll control.
    
    Args:
        is_finished (bool): Whether the import process has completed
        
    Returns:
        str: JavaScript code for browser behavior control
        
    JavaScript Features:
        1. Auto-scroll to bottom to show latest log entries
        2. Auto-refresh page every REFRESH_INTERVAL if not finished
        3. Stop refresh when import completes
        
    Auto-Refresh Logic:
        - Continuously refreshes page to show new log content
        - Stops refreshing when completion marker detected
        - Provides real-time monitoring experience
        
    Scroll Behavior:
        - Always scrolls to bottom after page load
        - Ensures latest log entries are visible
        - Improves user experience for long logs
    """
    js_code = []
    js_code.append("<script type='text/javascript'>")
    js_code.append("    // Auto-scroll to bottom to show latest log entries")
    js_code.append("    window.scrollTo(0, document.body.scrollHeight);")
    
    if not is_finished:
        js_code.append(f"    // Auto-refresh every {REFRESH_INTERVAL}ms until completion")
        js_code.append(f"    setTimeout(function() {{ window.location.reload(); }}, {REFRESH_INTERVAL});")
    else:
        js_code.append("    // Import completed - no more auto-refresh")
        js_code.append("    console.log('Import process completed.');")
    
    js_code.append("</script>")
    
    return "\n".join(js_code)


def generate_html_footer():
    """
    Generate HTML document footer and closing tags.
    
    Returns:
        str: HTML footer content with proper document closure
        
    Footer Content:
        - Closes log container div
        - Closes HTML body and document tags
        - Ensures proper HTML structure
    """
    footer = []
    footer.append("    </div>\n")  # Close log-container
    footer.append("</body>\n")
    footer.append("</html>\n")
    
    return "".join(footer)


def main():
    """
    Main CGI execution function for import status monitoring.
    
    Process:
        1. Parse query parameters to get import ticket ID
        2. Construct log file path from ticket ID
        3. Read and process log file content
        4. Generate HTML response with log display
        5. Add JavaScript for auto-refresh and scrolling
        6. Output complete HTML response
        
    Error Handling:
        - Graceful handling of missing parameters
        - Fallback for missing or inaccessible log files
        - User-friendly error messages in HTML output
        
    Real-time Features:
        - Live log file monitoring
        - Auto-refresh until completion
        - Auto-scroll for latest entries
        
    Security Considerations:
        - HTML escaping of log content
        - Parameter validation for ticket ID
        - Safe file path construction
    """
    try:
        # Parse CGI parameters
        params = parse_query_parameters()
        import_ticket = params.get('importTicket', '')
        
        if not import_ticket:
            # Handle missing import ticket
            sys.stdout.write("Content-Type: text/html; charset=UTF-8\r\n")
            sys.stdout.write("\r\n")
            sys.stdout.write("<html><body>")
            sys.stdout.write("<h2>Error: Missing Import Ticket</h2>")
            sys.stdout.write("<p>No import ticket specified. Please provide an importTicket parameter.</p>")
            sys.stdout.write("</body></html>")
            sys.stdout.flush()
            return
        
        # Construct log file path
        log_file_path = os.path.join(LOG_FILE_DIRECTORY, f"{import_ticket}.log")
        
        # Generate HTML header
        sys.stdout.write(generate_html_header())
        
        # Display import ticket information
        sys.stdout.write(f"<p><strong>Import Ticket:</strong> {import_ticket}</p>\n")
        sys.stdout.write(f"<p><strong>Log File:</strong> {log_file_path}</p>\n")
        sys.stdout.write("<hr>\n")
        
        # Read and display log content
        log_lines, is_finished = read_import_log(log_file_path)
        
        if log_lines:
            for line in log_lines:
                formatted_line = format_log_line(line)
                sys.stdout.write(formatted_line)
                sys.stdout.write("\n")
        else:
            sys.stdout.write("<p><em>No log content available yet.</em></p>")
        
        # Add completion status
        if is_finished:
            sys.stdout.write("<hr>\n")
            sys.stdout.write("<p class='success'><strong>Import Status: COMPLETED</strong></p>\n")
        else:
            sys.stdout.write("<hr>\n")
            sys.stdout.write("<p class='status'><strong>Import Status: IN PROGRESS</strong></p>\n")
        
        # Add JavaScript controls
        sys.stdout.write(generate_javascript_controls(is_finished))
        
        # Generate HTML footer
        sys.stdout.write(generate_html_footer())
        
        # Ensure output is flushed
        sys.stdout.flush()
        
    except Exception as e:
        # Handle unexpected errors
        sys.stdout.write("Content-Type: text/html; charset=UTF-8\r\n")
        sys.stdout.write("\r\n")
        sys.stdout.write("<html><body>")
        sys.stdout.write("<h2>Error</h2>")
        sys.stdout.write(f"<p>An error occurred while monitoring import status: {str(e)}</p>")
        sys.stdout.write("</body></html>")
        sys.stdout.flush()


if __name__ == "__main__":
    main()

